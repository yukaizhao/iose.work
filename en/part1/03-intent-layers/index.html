<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-3DG40LJYZ7"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3DG40LJYZ7")</script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Êô∫ËÉΩÊó∂‰ª£ËΩØ‰ª∂Â∑•Á®ã‰ªé‰ª£Á†ÅÂà∞ÊÑèÂõæÁöÑËåÉÂºèÈù©ÂëΩ"><meta name=keywords content="Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã,IOSE,Intent-Oriented Software Engineering,AI Agent,ËΩØ‰ª∂Â∑•Á®ãËåÉÂºè,ÊÑèÂõæÈ©±Âä®ÂºÄÂèë,‰∫∫Êú∫Âçè‰Ωú,Â§ßÊ®°ÂûãËΩØ‰ª∂Â∑•Á®ã"><meta name=author content="IOSE Team"><meta name=robots content="index, follow"><link rel=canonical href=/en/part1/03-intent-layers/><meta property="og:type" content="website"><meta property="og:url" content="/en/part1/03-intent-layers/"><meta property="og:title" content="Chapter 3: Intent Layering | Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã"><meta property="og:description" content="Êô∫ËÉΩÊó∂‰ª£ËΩØ‰ª∂Â∑•Á®ã‰ªé‰ª£Á†ÅÂà∞ÊÑèÂõæÁöÑËåÉÂºèÈù©ÂëΩ"><meta property="og:site_name" content="Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã"><meta property="og:locale" content="en_US"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Chapter 3: Intent Layering | Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã"><meta name=twitter:description content="Êô∫ËÉΩÊó∂‰ª£ËΩØ‰ª∂Â∑•Á®ã‰ªé‰ª£Á†ÅÂà∞ÊÑèÂõæÁöÑËåÉÂºèÈù©ÂëΩ"><link rel=icon type=image/svg+xml href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéØ</text></svg>"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=/css/style.css><script type=application/ld+json>{"@context":"https://schema.org","@type":"Book","name":"Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã","alternateName":"Intent-Oriented Software Engineering","description":"Êô∫ËÉΩÊó∂‰ª£ËΩØ‰ª∂Â∑•Á®ã‰ªé‰ª£Á†ÅÂà∞ÊÑèÂõæÁöÑËåÉÂºèÈù©ÂëΩ","inLanguage":["zh-CN","en-US"],"author":{"@type":"Organization","name":"IOSE Team"},"about":{"@type":"Thing","name":"Software Engineering Paradigm","description":"AI-driven intent-oriented software development methodology"},"keywords":["IOSE","AI Agent","Intent-Driven Development","Software Engineering","Human-AI Collaboration"]}</script><title>Chapter 3: Intent Layering | Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã</title></head><body class=has-sidebar><header class=site-header><div class=container><div class=header-inner><a href=/ class=logo><span class=logo-icon>üéØ</span>
<span class=logo-text>IOSE</span></a><div class=header-slogan><span class=slogan-main>Èù¢ÂêëÊÑèÂõæ<br class=mobile-br>ËΩØ‰ª∂Â∑•Á®ã</span>
<span class=slogan-divider></span>
<span class=slogan-sub>Êô∫ËÉΩÊó∂‰ª£ËΩØ‰ª∂Â∑•Á®ã‰ªé‰ª£Á†ÅÂà∞ÊÑèÂõæÁöÑËåÉÂºèÈù©ÂëΩ</span></div><button type=button class=header-toc-btn id=headerChapterNavToggle aria-label="Open chapter list">
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
<span class=header-toc-btn-text>Chapters</span></button><div class=header-actions><a href=/read/ class="btn btn-sm btn-primary">‰∏≠Êñá</a>
<a href=/en/read/ class="btn btn-sm btn-secondary">English</a></div></div></div></header><main class=main-content><article class="page-content with-sidebar"><nav class=chapter-nav id=chapterNav><div class=chapter-nav-header><button class=chapter-nav-toggle id=chapterNavToggle aria-label="Toggle chapter navigation">
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
</button>
<span class=chapter-nav-title>Chapters</span></div><div class=chapter-nav-content id=chapterNavContent><div class=chapter-part><div class=chapter-part-header><span class=chapter-part-number>1</span>
<span class=chapter-part-title>Part 1: Foundational Concepts</span></div><ul class=chapter-list-nav><li class=chapter-item><a href=/en/part1/01-what-is-iose/ class=chapter-link><span class=chapter-num>01</span>
<span class=chapter-title>Chapter 1: What is Intent-Oriented Software Engineering</span></a></li><li class=chapter-item><a href=/en/part1/02-why-iose/ class=chapter-link><span class=chapter-num>02</span>
<span class=chapter-title>Chapter 2: Why This Transformation is Needed</span></a></li><li class="chapter-item active"><a href=/en/part1/03-intent-layers/ class=chapter-link><span class=chapter-num>03</span>
<span class=chapter-title>Chapter 3: Intent Layering</span></a></li></ul></div><div class=chapter-part><div class=chapter-part-header><span class=chapter-part-number>2</span>
<span class=chapter-part-title>Part 2: Evolution and Transformation</span></div><ul class=chapter-list-nav></ul></div><div class=chapter-part><div class=chapter-part-header><span class=chapter-part-number>3</span>
<span class=chapter-part-title>Part 3: Practical Implementation</span></div><ul class=chapter-list-nav></ul></div><div class=chapter-part><div class=chapter-part-header><span class=chapter-part-number>4</span>
<span class=chapter-part-title>Part 4: Future Perspectives</span></div><ul class=chapter-list-nav></ul></div></div></nav><div class=chapter-nav-overlay id=chapterNavOverlay></div><div class=content-main><div class=content-wrapper><div class=content-toc-wrapper><nav class=content-toc id=contentToc><div class=content-toc-header><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
<span>Contents</span>
<button class=content-toc-toggle id=contentTocToggle aria-label="Toggle TOC">
<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg></button></div><div class=content-toc-body id=contentTocBody><ul class=content-toc-list><li class="content-toc-item toc-h2"><a href=#1-why-layering-is-needed class=content-toc-link>1 Why Layering is Needed</a></li><li class="content-toc-item toc-h2"><a href=#2-the-three-layer-intent-model class=content-toc-link>2 The Three-Layer Intent Model</a></li><li class="content-toc-item toc-h3"><a href=#business-intent class=content-toc-link>Business Intent</a></li><li class="content-toc-item toc-h3"><a href=#product-intent class=content-toc-link>Product Intent</a></li><li class="content-toc-item toc-h3"><a href=#technical-intent class=content-toc-link>Technical Intent</a></li><li class="content-toc-item toc-h2"><a href=#3-interaction-relationships-between-the-three-layers class=content-toc-link>3 Interaction Relationships Between the Three Layers</a></li><li class="content-toc-item toc-h3"><a href=#top-down-transformation-process class=content-toc-link>Top-Down Transformation Process</a></li><li class="content-toc-item toc-h3"><a href=#bottom-up-support-relationship class=content-toc-link>Bottom-Up Support Relationship</a></li><li class="content-toc-item toc-h3"><a href=#focus-subjects-of-each-layer class=content-toc-link>Focus Subjects of Each Layer</a></li><li class="content-toc-item toc-h2"><a href=#4-precision-principles-of-intent-expression class=content-toc-link>4 Precision Principles of Intent Expression</a></li><li class="content-toc-item toc-h3"><a href=#avoiding-ambiguity-from-vague-to-precise class=content-toc-link>Avoiding Ambiguity: From Vague to Precise</a></li><li class="content-toc-item toc-h3"><a href=#verifiability-ensuring-intent-can-be-verified class=content-toc-link>Verifiability: Ensuring Intent Can Be Verified</a></li><li class="content-toc-item toc-h2"><a href=#5-chapter-summary class=content-toc-link>5 Chapter Summary</a></li><li class="content-toc-item toc-h2"><a href=#practical-exercise class=content-toc-link>Practical Exercise</a></li></ul></div></nav></div><h1>Chapter 3: Intent Layering</h1><h2 id=1-why-layering-is-needed>1 Why Layering is Needed</h2><p>Intent is never a single-dimensional simple instruction, but a layered semantic system. Let us understand this through a concrete scenario: when an executive says &ldquo;we want to develop a membership system&rdquo; at a project kickoff meeting, different roles in the room actually receive completely different information‚Äî</p><p><strong>The CEO</strong> envisions numbers on financial statements: can this system improve user retention? Can it bring considerable revenue growth? How does it support the company&rsquo;s long-term competitive moat?</p><p><strong>The product manager</strong> is thinking about the functional blueprint: how many tiers should members be divided into? How should benefits be designed for each tier? What gradient should the pricing strategy adopt? How should it integrate with the existing points system?</p><p><strong>The technical lead&rsquo;s</strong> focus has already sunk to the technical level: how should this system ensure performance? How should data security be ensured? How should it run stably under high concurrency scenarios?</p><p>The same concept of a &ldquo;membership system&rdquo; presents completely different aspects in the cognition of different roles. This cognitive difference is not a communication failure, but an embodiment of the inherent complexity of software systems‚Äîit simultaneously involves multiple levels such as business value, product functionality, and technical constraints.</p><p><strong>The core purpose of intent layering is precisely to establish order within this complexity. It decomposes the vague &ldquo;develop a system&rdquo; into three clear levels: business intent sets the value direction, product intent defines specific functionality, and technical intent sets implementation boundaries. Among these, product intent and technical intent are the core operational interfaces of the IOSE transformation.</strong></p><h2 id=2-the-three-layer-intent-model>2 The Three-Layer Intent Model</h2><p>In the practice of intent-oriented software engineering, we divide intent into three levels, forming a clear value transmission chain:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    A[&#34;Business Intent Business&#34;]
    A_desc[&#34;Answers why to do it‚Äîvalue direction&#34;]
    B[&#34;Product Intent Product&#34;]
    B_desc[&#34;Answers what to do‚Äîfunction definition&#34;]
    C[&#34;Technical Intent Technical&#34;]
    C_desc[&#34;Answers how to do it correctly‚Äîconstraint boundaries&#34;]

    A --&gt; A_desc
    A --&gt; B
    B --&gt; B_desc
    B --&gt; C
    C --&gt; C_desc

    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style B fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style C fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style A_desc fill:#fafafa,stroke:#bdbdbd
    style B_desc fill:#fafafa,stroke:#bdbdbd
    style C_desc fill:#fafafa,stroke:#bdbdbd
</code></pre><p>These three levels have clear division of labor and progress layer by layer. <strong>Among them, product intent and technical intent are the core battlefields of the IOSE transformation</strong>‚Äîproduct personnel directly drive development by defining product intent, while technical personnel ensure AI generation quality by defining technical intent.</p><h3 id=business-intent>Business Intent</h3><p>Business intent focuses on macro-level business goals, answering the question of &ldquo;why do it.&rdquo; It usually comes from senior managers and sets the direction for the entire organization.</p><p><strong>Core Elements of Business Intent</strong>:</p><table><thead><tr><th>Element</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><strong>Business Goal</strong></td><td>Desired business outcome</td><td>Increase annual member renewal rate by 10%</td></tr><tr><td><strong>Value Proposition</strong></td><td>Core value created for the organization</td><td>Reduce passive churn, enhance user stickiness</td></tr><tr><td><strong>Strategic Context</strong></td><td>Why do this now</td><td>Market competition intensifying, member retention becoming a key metric</td></tr></tbody></table><p>Business intent is relatively stable and serves more as background context. In the IOSE transformation, it does not need to be frequently operated, but needs to be clearly understood and communicated.</p><p><strong>Business Intent Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>What we want to do:
</span></span><span style=display:flex><span>Improve the renewal rate of annual members
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Business Goals:
</span></span><span style=display:flex><span>- Increase annual member renewal rate from current 75% to 85%, i.e., reduce about 2,000 passive churn users per month
</span></span><span style=display:flex><span>- Through proactive service methods, let more members nearing expiration complete renewal in time
</span></span><span style=display:flex><span>- Expected annual revenue growth of approximately 5 million yuan
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Value Proposition:
</span></span><span style=display:flex><span>Value to the company:
</span></span><span style=display:flex><span>Reducing user churn means higher customer lifetime value. Each retained annual member can bring
</span></span><span style=display:flex><span>an additional 3 years of subscription revenue on average. Compared to the high cost of acquiring new customers, retaining existing users has higher ROI.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Value to users:
</span></span><span style=display:flex><span>Help users avoid benefit interruptions caused by forgetting or negligence, ensure they can continuously enjoy member privileges,
</span></span><span style=display:flex><span>and enhance user loyalty and satisfaction with the platform.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Strategic Context:
</span></span><span style=display:flex><span>- Intensifying market competition: In the past two years, customer acquisition costs in the same industry have risen by 40%. Relying solely on new customer-driven
</span></span><span style=display:flex><span>growth models is no longer sustainable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- Company strategic transformation: This year, the company explicitly proposed transforming from &#34;traffic-oriented&#34; to &#34;user value-oriented&#34;,
</span></span><span style=display:flex><span>with existing user operations becoming a core strategy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- Data-discovered problems: User research shows that over 60% of churned members cite &#34;forgot to renew&#34; as the main reason,
</span></span><span style=display:flex><span>rather than dissatisfaction with the service, indicating huge room for recovery
</span></span></code></pre></div><h3 id=product-intent>Product Intent</h3><p>Product intent is the bridge connecting business and technology. It transforms abstract business goals into specific product functional solutions, answering the question of &ldquo;what to do.&rdquo;</p><p><strong>Core Elements of Product Intent</strong>:</p><ul><li><strong>Functional Goal</strong>: What specific functionality to implement, what problem to solve</li><li><strong>Target Users</strong>: Who is the user group served by this functionality, what are their characteristics</li><li><strong>Usage Scenarios</strong>: Under what circumstances is the functionality used, what are the trigger conditions</li><li><strong>User Experience</strong>: How do users perceive this functionality, what is the operation path</li><li><strong>Acceptance Criteria</strong>: How to measure whether the functionality is successful, what quantifiable indicators are there</li></ul><p><strong>Product intent is one of the core operational objects of the IOSE transformation.</strong> Under the IOSE paradigm, the product manager&rsquo;s work focus shifts from writing PRDs and drawing prototypes to defining structured product intent. This structured product intent can directly drive AI to generate runnable software, giving product personnel the ability to directly create digital products.</p><p>Product intent expression has two main forms: <strong>text description</strong> is used to express functional logic and business processes, and <strong>Figma design drafts</strong> are used to precisely express user interfaces.</p><h4 id=text-expression-describing-functionality-and-processes>Text Expression: Describing Functionality and Processes</h4><p>Text form is suitable for describing functional logic, business processes, algorithm rules, etc. that do not involve complex interfaces. It clearly elaborates in natural language &ldquo;what to do,&rdquo; &ldquo;for whom,&rdquo; &ldquo;in what scenario to use,&rdquo; and &ldquo;how to measure success.&rdquo;</p><p><strong>Text-Based Product Intent Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>Functional Goal:
</span></span><span style=display:flex><span>Develop a benefit expiration reminder function for annual members. When user membership is about to expire,
</span></span><span style=display:flex><span>reach them through multiple channels including app push notifications and email, reminding users to renew in time,
</span></span><span style=display:flex><span>thereby reducing passive churn caused by forgetting.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Target Users:
</span></span><span style=display:flex><span>Annual members, especially the user group within 30 days of expiration. According to data analysis, this group
</span></span><span style=display:flex><span>has high renewal willingness but is prone to benefit interruption due to forgetting.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Usage Scenarios:
</span></span><span style=display:flex><span>When a member&#39;s annual benefit is about to expire within 30 days, the system needs to proactively initiate reminders:
</span></span><span style=display:flex><span>- 30 days before expiration: First friendly reminder, informing that benefits are about to expire
</span></span><span style=display:flex><span>- 7 days before expiration: Second reminder, emphasizing benefit value and renewal discounts
</span></span><span style=display:flex><span>- 1 day before expiration: Final reminder, creating urgency
</span></span><span style=display:flex><span>Reminder channels include app push notifications and email.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>User Experience:
</span></span><span style=display:flex><span>- Reminder content is clear and explicit: clearly inform expiration time, remaining benefit value, and what will be lost without renewal
</span></span><span style=display:flex><span>- Operation path is extremely simple: provide one-click renewal shortcut entry, users can complete payment without multiple jumps
</span></span><span style=display:flex><span>- Respect user choice: provide &#34;remind again in 7 days&#34; and &#34;do not remind again&#34; options, avoiding excessive disturbance
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Acceptance Criteria:
</span></span><span style=display:flex><span>Functional Accuracy:
</span></span><span style=display:flex><span>- Reminder trigger timing is accurate, triggered at 30 days, 7 days, and 1 day before expiration respectively
</span></span><span style=display:flex><span>- Reminder target screening is correct, excluding users who have renewed or turned off auto-renewal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Business Effect:
</span></span><span style=display:flex><span>- Reminder open rate &gt; 60% (i.e., among users who receive reminders, over 60% will click to view)
</span></span><span style=display:flex><span>- Renewal conversion rate &gt; 15% (i.e., among users who click to view, over 15% will complete renewal)
</span></span><span style=display:flex><span>- User complaint rate &lt; 1% (complaints caused by excessive disturbance or inaccurate reminders)
</span></span></code></pre></div><h4 id=figma-expression-precisely-describing-user-interfaces>Figma Expression: Precisely Describing User Interfaces</h4><p>When product intent involves user interfaces, pure text description is often difficult to precisely convey visual details‚Äîthe specific position of buttons, color values, font sizes, element spacing, and other information are both lengthy and prone to ambiguity when described in text. At this time, <strong>Figma design drafts</strong> are the best tool for expressing interface intent.</p><p>The essential advantage of Figma lies in its definition of design as <strong>data</strong>:</p><ul><li>Traditional design tools output <strong>pixels (images)</strong>. Large models need to &ldquo;understand&rdquo; visual elements and reason about their structure and style. This process not only consumes significant computing power but also easily loses details (such as precise spacing, color values, font parameters).</li><li>Every interface element in Figma‚Äîfrom button position coordinates, color values to text font and spacing parameters‚Äîis <strong>structured data</strong>. Figma&rsquo;s file format is essentially a form of &ldquo;pseudo-code&rdquo; that can be precisely read and programmatically operated.</li></ul><p>Therefore, when product intent includes interfaces, <strong>prioritize providing Figma design draft links or exported structured data</strong> rather than screenshots or pure text descriptions. This allows AI to accurately reproduce design intent, rather than guessing from vague visual information.</p><p><strong>Interface-Based Product Intent Example</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>Functional Goal:
</span></span><span style=display:flex><span>Design push notification cards and email pages for member renewal reminders to improve user click-through and renewal conversion rates.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Interface Deliverables:
</span></span><span style=display:flex><span>- Figma design draft link: https://figma.com/file/xxx/member-renewal
</span></span><span style=display:flex><span>- Or exported structured data file (such as JSON generated by figma-to-code plugin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Key Interface Descriptions:
</span></span><span style=display:flex><span>1. App Push Notification Card
</span></span><span style=display:flex><span>   - Display position: Phone lock screen and notification center
</span></span><span style=display:flex><span>   - Content elements: Member level icon, benefit expiration countdown, renewal button
</span></span><span style=display:flex><span>   - Interaction: Swipe left to close, click to enter renewal page
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2. Email Reminder Page
</span></span><span style=display:flex><span>   - Top: Brand logo and member exclusive identification
</span></span><span style=display:flex><span>   - Body: Benefit list (used/unused), expiration time, renewal discount
</span></span><span style=display:flex><span>   - Bottom: One-click renewal button, customer service contact, unsubscribe link
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Design Specifications:
</span></span><span style=display:flex><span>- Follow iOS/Android official push design specifications
</span></span><span style=display:flex><span>- Email width limited to within 600px to ensure compatibility across clients
</span></span><span style=display:flex><span>- Button color uses brand primary color #FF6B35 to ensure clear visual hierarchy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Acceptance Criteria:
</span></span><span style=display:flex><span>- Design drafts fully cover both push cards and email forms
</span></span><span style=display:flex><span>- All visual elements are marked with clear dimensions, colors, and font parameters
</span></span><span style=display:flex><span>- Provide adaptation solutions for mobile and desktop
</span></span></code></pre></div><h3 id=technical-intent>Technical Intent</h3><p>The core mission of technical intent is to <strong>transform product intent into specific plans that coding agents can understand and execute</strong>, while ensuring the implementation process conforms to quality boundaries. It answers two key questions: &ldquo;how to make AI understand requirements&rdquo; and &ldquo;how to do it correctly.&rdquo;</p><p>Technical intent contains two major components:</p><p><strong>Part One: Implementation Specifications (How to Implement)</strong></p><p>This part focuses on decomposing product functionality into technical plans that agents can execute, and is the most transformative content of technical intent.</p><table><thead><tr><th>Element</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><strong>Requirement Decomposition</strong></td><td>Decompose product functionality into independently implementable technical modules</td><td>Decompose into &ldquo;reminder generator,&rdquo; &ldquo;push service,&rdquo; and &ldquo;email service&rdquo; three modules</td></tr><tr><td><strong>Technical Design</strong></td><td>Key design decisions: architecture choice, data model, interface contract</td><td>Adopt event-driven architecture; define Reminder, Notification domain models</td></tr><tr><td><strong>Task Decomposition</strong></td><td>Decompose implementation work into development tasks that agents can execute</td><td>Task1: Define data model; Task2: Implement reminder generation logic</td></tr><tr><td><strong>Acceptance Specifications</strong></td><td>Completion criteria and validation methods for each task</td><td>Unit tests pass; interface contract conforms to OpenAPI specification</td></tr></tbody></table><p><strong>Part Two: Quality Constraints</strong></p><p>This part defines the boundary conditions that must be followed during implementation.</p><table><thead><tr><th>Element</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><strong>Performance Constraints</strong></td><td>Response time, throughput, resource consumption</td><td>Interface P99 response time &lt; 50ms</td></tr><tr><td><strong>Security Constraints</strong></td><td>Security baselines and compliance requirements</td><td>All interfaces must be authenticated through OAuth2.0</td></tr><tr><td><strong>Code Quality Constraints</strong></td><td>Code quality and maintainability standards</td><td>Unit test coverage > 80%</td></tr><tr><td><strong>Architecture Quality Constraints</strong></td><td>System structure health</td><td>Module size, cyclomatic complexity, layering direction constraints</td></tr><tr><td><strong>Dependency Constraints</strong></td><td>Technology stack and infrastructure limitations</td><td>Must use MySQL 8.0</td></tr></tbody></table><p><strong>Special Note on Architecture Quality Constraints</strong>:</p><p>Architecture quality constraints are a key mechanism in the IOSE paradigm to ensure long-term software maintainability. When AI agents continuously generate and modify code, without clear architecture boundary constraints, systems can easily fall into &ldquo;chaotic growth&rdquo;‚Äîblurred module responsibilities, complex interdependencies, and out-of-control code complexity. This not only affects human understanding but also significantly reduces the efficiency of AI agents&rsquo; subsequent work.</p><p><strong>Core Architecture Constraint Elements</strong>:</p><ul><li><p><strong>Layering Direction Constraints</strong>: Strictly define the dependency direction of each layer in a layered architecture (such as classic three-layer architecture: Controller ‚Üí Service ‚Üí Repository), prohibiting reverse dependencies or cross-layer calls. This ensures that AI does not break the clear boundaries of architecture when generating new code.</p></li><li><p><strong>Cyclomatic Complexity Control</strong>: Require that the cyclomatic complexity of each function/method does not exceed 10 (or team-agreed threshold). High complexity code is not only difficult to maintain but also makes it difficult for AI to grasp logical boundaries during subsequent modifications, easily producing bugs.</p></li><li><p><strong>Module Size Constraints</strong>: Limit the number of lines of code for a single file, single class, and single function (such as single file not exceeding 500 lines, single function not exceeding 50 lines). Appropriate granularity allows AI to more precisely locate modification scope, reduce the impact surface of changes, and improve generation efficiency.</p></li></ul><p>Through these constraints, we ensure that AI agents always face a codebase with clear structure and well-defined boundaries during continuous work, thereby maintaining efficient code generation and modification capabilities.</p><p><strong>Technical intent is the core operational object of the IOSE transformation.</strong> Developers shift from &ldquo;personally writing every line of code&rdquo; to &ldquo;defining implementation specifications and reviewing AI execution.&rdquo; High-quality technical intent should be clear enough that agent tools like Cursor and Claude Code can autonomously complete development tasks based on it.</p><h4 id=practical-references-for-technical-intent>Practical References for Technical Intent</h4><p>In actual work, writing technical intent can refer to the following tools and concepts:</p><p><strong>Reference Cursor&rsquo;s Agent Mode</strong>: Cursor&rsquo;s Composer function demonstrates how to transform requirement descriptions into multi-file code modifications. In technical intent, we need to provide a similar &ldquo;context map&rdquo;‚Äîexplaining the responsibilities of each module, how they interact with other modules, and the organization structure of key files.</p><p><strong>Reference Claude Code&rsquo;s Spec-Driven Approach</strong>: When handling complex tasks, Claude Code first confirms the &ldquo;Implementation Plan&rdquo; with the user. The &ldquo;task decomposition&rdquo; section in technical intent is exactly such an implementation plan. It needs to clearly define the input, output, and acceptance criteria for each subtask.</p><p><strong>Reference Kiro&rsquo;s Specification-Driven Development</strong>: Kiro emphasizes &ldquo;Specs as Code,&rdquo; meaning that specification documents themselves are executable constraints. The &ldquo;acceptance specifications&rdquo; in technical intent should be precise enough to be validated by automated tools‚Äîsuch as through unit test assertions, API contract tests, or static code analysis to ensure implementation conforms to specifications.</p><h2 id=3-interaction-relationships-between-the-three-layers>3 Interaction Relationships Between the Three Layers</h2><p>Business intent, product intent, and technical intent are not three independent islands, but an organic whole. Understanding their interaction relationships is crucial for effectively applying intent layering.</p><h3 id=top-down-transformation-process>Top-Down Transformation Process</h3><p>In actual software planning processes, high-level business intent needs to be transformed into executable technical plans layer by layer:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    A[&#34;Business Intent: Increase member renewal rate by 10%&#34;]
    B[&#34;Product Intent: Benefit expiration reminder function&#34;]
    C[&#34;Technical Intent A: Reminder generation service&#34;]
    D[&#34;Technical Intent B: Push notification service&#34;]
    E[&#34;Technical Intent C: Renewal page optimization&#34;]

    A --&gt; B
    B --&gt; C
    B --&gt; D
    B --&gt; E

    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style B fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style C fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style D fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style E fill:#fff3e0,stroke:#f57c00,stroke-width:2px
</code></pre><p>Business intent answers &ldquo;why do it,&rdquo; providing direction guidance for product intent; product intent answers &ldquo;what to do,&rdquo; transforming business goals into specific functional solutions; technical intent answers &ldquo;how to do it correctly,&rdquo; setting quality boundaries for product implementation.</p><h3 id=bottom-up-support-relationship>Bottom-Up Support Relationship</h3><p>Conversely, each layer of intent provides implementation support for the layer above:</p><ul><li><strong>Technical intent supports product intent</strong>: Without performance constraints, reminder services may crash during peak periods, and product functionality cannot operate normally; without security constraints, user data leaks, and product value is lost.</li><li><strong>Product intent supports business intent</strong>: If product functionality design is unreasonable and users are unwilling to use it, business goals cannot be achieved; if acceptance criteria are improperly set and actual effects cannot be measured, business value cannot be verified.</li></ul><p><strong>Product intent and technical intent are the core operational interfaces of the IOSE transformation.</strong> Product personnel directly drive AI to understand &ldquo;what to do&rdquo; by defining clear product intent; technical personnel ensure AI knows &ldquo;how to do it correctly&rdquo; by defining complete technical intent. Together, they constitute the main channel for human-AI collaboration.</p><h3 id=focus-subjects-of-each-layer>Focus Subjects of Each Layer</h3><table><thead><tr><th>Intent Level</th><th>Primary Focus</th><th>Core Question</th><th>Role in IOSE</th></tr></thead><tbody><tr><td><strong>Business Intent</strong></td><td>Senior managers, business leaders</td><td>&ldquo;Why do it&rdquo;</td><td>Provides direction background, relatively stable</td></tr><tr><td><strong>Product Intent</strong></td><td>Product managers, business analysts</td><td>&ldquo;What to do&rdquo;</td><td><strong>Core operational object, directly drives development</strong></td></tr><tr><td><strong>Technical Intent</strong></td><td>Technical leads, architects</td><td>&ldquo;How to do it correctly&rdquo;</td><td><strong>Core operational object, ensures AI generation quality</strong></td></tr></tbody></table><h2 id=4-precision-principles-of-intent-expression>4 Precision Principles of Intent Expression</h2><p>The quality of intent expression directly determines whether AI agents can accurately understand and execute. Here are two key principles:</p><h3 id=avoiding-ambiguity-from-vague-to-precise>Avoiding Ambiguity: From Vague to Precise</h3><p>Natural language itself has inherent ambiguity, but intent documents require eliminating this ambiguity as much as possible. Here are some common comparison examples:</p><table><thead><tr><th>Vague Expression (Should Avoid)</th><th>Precise Expression (Recommended)</th></tr></thead><tbody><tr><td>&ldquo;Complete as soon as possible&rdquo;</td><td>&ldquo;Complete development within 3 working days, deploy within 1 week&rdquo;</td></tr><tr><td>&ldquo;Performance should be good&rdquo;</td><td>&ldquo;Interface P99 response time &lt; 100ms, support 1000 QPS concurrency&rdquo;</td></tr><tr><td>&ldquo;User experience friendly&rdquo;</td><td>&ldquo;Page first load time &lt; 2 seconds, error prompts in Chinese with specific operation suggestions&rdquo;</td></tr><tr><td>&ldquo;Ensure security&rdquo;</td><td>&ldquo;All APIs must be authenticated through OAuth2.0, sensitive data encrypted with AES-256&rdquo;</td></tr><tr><td>&ldquo;System should be stable&rdquo;</td><td>&ldquo;System availability > 99.9%, fault recovery time &lt; 30 minutes&rdquo;</td></tr></tbody></table><h3 id=verifiability-ensuring-intent-can-be-verified>Verifiability: Ensuring Intent Can Be Verified</h3><p>Every intent should be objectively verifiable. If an intent cannot be verified, it cannot serve as an execution target and acceptance criterion for AI agents.</p><blockquote><p><strong>Not-so-good intent example</strong>: &ldquo;The system should run stably&rdquo;</p><p>Problem: &ldquo;Stable&rdquo; is a subjective concept, different people may have different understandings</p><p><strong>Improved intent</strong>: &ldquo;System availability > 99.9%, fault recovery time &lt; 30 minutes, unplanned downtime &lt; 43 minutes per month&rdquo;</p><p>Advantage: Clear metrics, measurable, verifiable</p></blockquote><h2 id=5-chapter-summary>5 Chapter Summary</h2><p>Intent layering is the theoretical cornerstone and practical guide of intent-oriented software engineering. Through this chapter&rsquo;s study, we should master the following core points:</p><ol><li><strong>Business intent</strong> answers &ldquo;why do it&rdquo;‚Äîit sets the value direction and provides background for product intent;</li><li><strong>Product intent</strong> answers &ldquo;what to do&rdquo;‚Äîit transforms business goals into specific functional solutions and is <strong>the core operational object of the IOSE transformation</strong>;</li><li><strong>Technical intent</strong> answers &ldquo;how to make AI understand and implement&rdquo;‚Äîit includes implementation specifications (requirement decomposition, technical design, task decomposition) and quality constraints, and is <strong>the technical core of the IOSE transformation</strong>;</li><li><strong>Precision expression</strong> principles eliminate natural language ambiguity, ensuring intent can be accurately understood and verified by AI.</li></ol><p>The benefits of this three-layer structure are manifold:</p><ul><li><strong>Business personnel</strong> can focus on value direction without getting bogged down in functional details;</li><li><strong>Product personnel</strong> can focus on functional definition, directly driving development through structured intent;</li><li><strong>Technical personnel</strong> shift from coding executors to specification definers, guiding AI to complete implementation through technical intent;</li><li><strong>AI agents</strong> obtain clear, structured, executable input, capable of autonomously completing the entire process from design to coding.</li></ul><p><strong>Core Insight</strong>: Under the IOSE paradigm, the value of technical personnel is no longer reflected in &ldquo;speed of writing code,&rdquo; but in &ldquo;ability to define clear specifications.&rdquo; An excellent technical intent should be complete enough that agents like Cursor and Claude Code can autonomously complete development tasks based on it, while humans only need to review and accept.</p><p>In the next chapter, we will further compare the core differences between old and new software engineering paradigms, deeply understanding the profound impact and significance of this transformation.</p><hr><h2 id=practical-exercise>Practical Exercise</h2><p>To help you better master intent layering, it is recommended to complete the following practical exercise:</p><p><strong>Exercise Task</strong>: Choose a specific feature you are currently responsible for or familiar with, and try to write according to the templates introduced in this chapter:</p><ol><li>A business intent document (briefly explain business background and goals)</li><li>A product intent document (refer to section 3.2.2 template, describe functional definition in detail)</li><li>A technical intent document (refer to section 3.2.3 template, clarify technical constraints)</li></ol><p><strong>Self-Check List After Completion</strong>:</p><ul><li><input disabled type=checkbox> Do the three levels of intent form a clear value chain?</li><li><input disabled type=checkbox> Does product intent transform business goals into specific executable functional solutions?</li><li><input disabled type=checkbox> Does technical intent contain complete implementation specifications (requirement decomposition, technical design, task decomposition)?</li><li><input disabled type=checkbox> Is task decomposition detailed enough for agents to understand each task&rsquo;s input and output?</li><li><input disabled type=checkbox> Are acceptance specifications quantifiable and automatically verifiable?</li><li><input disabled type=checkbox> If these documents are given to Cursor or Claude Code, can it autonomously complete development based on them?</li></ul><nav class=chapter-nav-footer><a href=/en/part1/02-why-iose/ class=chapter-nav-prev><span class=chapter-nav-label><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>
Previous
</span><span class=chapter-nav-title>Chapter 2: Why This Transformation is Needed</span>
</a><span class="chapter-nav-next disabled"><span class=chapter-nav-label>Next
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
</span><span class=chapter-nav-title>None</span></span></nav></div></div></article></main><footer class=site-footer><div class=container><div class=footer-inner><div class=footer-main><div class=footer-brand><span class=logo-icon>üéØ</span>
<span class=logo-text>IOSE</span></div><div class=footer-slogan><div class=slogan-main>Èù¢ÂêëÊÑèÂõæËΩØ‰ª∂Â∑•Á®ã</div><div class=slogan-divider style=height:4px></div><div class=slogan-sub>Êô∫ËÉΩÊó∂‰ª£ËΩØ‰ª∂Â∑•Á®ã‰ªé‰ª£Á†ÅÂà∞ÊÑèÂõæÁöÑËåÉÂºèÈù©ÂëΩ</div></div><p class=footer-desc>Êú¨‰π¶Á≥ªÁªüÈòêËø∞‰∫Ü Intent-Oriented Software EngineeringÔºàIOSEÔºâÁöÑÁêÜËÆ∫Ê°ÜÊû∂‰∏éÂÆûË∑µÊñπÊ≥ïÔºåÂ∏ÆÂä©ÂºÄÂèëÂõ¢ÈòüÈÄÇÂ∫î AI È©±Âä®ÁöÑËΩØ‰ª∂Â∑•Á®ãÊñ∞ËåÉÂºè„ÄÇ‰ªéÂü∫Á°ÄÊ¶ÇÂøµÂà∞Âõ¢ÈòüËΩ¨ÂûãÔºå‰ªéÂ∑•Á®ãÂÆûË∑µÂà∞Êú™Êù•Â±ïÊúõÔºå‰∏∫ËØªËÄÖÊèê‰æõÂÆåÊï¥ÁöÑÊñπÊ≥ïËÆ∫ÊåáÂØº„ÄÇ</p></div><div class=footer-donate><h4>ÊîØÊåÅ‰ΩúËÄÖ</h4><p class=donate-text>Â¶ÇÊûúËßâÂæóÊúâÊî∂ÁõäÔºåÊ¨¢ËøéÊâìËµè‰ΩúËÄÖ</p><img src=/images/buy-me-coffee.jpg alt="Buy me a coffee" width=200 height=200><p class=footer-copyright>¬© 2026 IOSE</p></div></div></div></footer><script>(function(){const u=1024,e=document.getElementById("chapterNav"),h=document.getElementById("chapterNavToggle"),i=document.getElementById("chapterNavOverlay"),c=document.getElementById("headerChapterNavToggle");function o(){return window.innerWidth<=u}function a(t){if(!e)return;e.classList.toggle("open",t),i&&i.classList.toggle("active",t),document.body.style.overflow=t?"hidden":""}function l(){if(!e)return;a(!e.classList.contains("open"))}if(e&&h){const t=localStorage.getItem("chapterNavCollapsed");!o()&&t==="true"&&(e.classList.add("collapsed"),document.body.classList.add("sidebar-collapsed")),h.addEventListener("click",function(){o()?l():(e.classList.toggle("collapsed"),document.body.classList.toggle("sidebar-collapsed"),localStorage.setItem("chapterNavCollapsed",e.classList.contains("collapsed")))}),i&&i.addEventListener("click",function(){a(!1)}),window.addEventListener("resize",function(){o()||a(!1),e.classList.contains("collapsed")?document.body.classList.add("sidebar-collapsed"):document.body.classList.remove("sidebar-collapsed")})}e&&c&&c.addEventListener("click",function(){o()&&l()});var s,d=document.querySelector(".content-toc-wrapper");d&&window.innerWidth<=u&&(s=document.querySelector(".content-wrapper h1"),s&&s.parentNode.insertBefore(d,s.nextSibling));const t=document.getElementById("contentTocToggle"),n=document.getElementById("contentTocBody");if(t&&n){const e=localStorage.getItem("contentTocCollapsed"),s=window.innerWidth<=768;e===null||e==="false"?s&&e===null?(n.classList.add("collapsed"),t.classList.add("collapsed"),localStorage.setItem("contentTocCollapsed","true")):(n.classList.remove("collapsed"),t.classList.remove("collapsed")):e==="true"&&(n.classList.add("collapsed"),t.classList.add("collapsed")),t.addEventListener("click",function(){n.classList.toggle("collapsed"),t.classList.toggle("collapsed"),localStorage.setItem("contentTocCollapsed",n.classList.contains("collapsed"))})}const m=document.querySelectorAll(".content-toc-link"),r=document.querySelectorAll(".content-wrapper h2[id], .content-wrapper h3[id]");if(m.length>0&&r.length>0){function f(){const t=window.innerWidth<=768?88:120,e=window.scrollY+t;r.forEach(function(t,n){const o=t.offsetTop,s=r[n+1],i=s?s.offsetTop:1/0;if(e>=o&&e<i){m.forEach(function(e){e.parentElement.classList.remove("active")});const e=document.querySelector('.content-toc-link[href="#'+t.id+'"]');e&&e.parentElement.classList.add("active")}})}window.addEventListener("scroll",f,{passive:!0}),f()}document.querySelectorAll('a[href^="#"]').forEach(function(e){e.addEventListener("click",function(e){const t=this.getAttribute("href");if(t==="#")return;const n=document.querySelector(t);if(n){e.preventDefault();const t=88,s=n.getBoundingClientRect().top,o=s+window.pageYOffset-t;window.scrollTo({top:o,behavior:"smooth"})}})})})()</script><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js></script><script>(function(){const e=document.querySelectorAll("code.language-mermaid");e.forEach(function(e){const n=e.parentElement,t=document.createElement("div");t.className="mermaid",t.textContent=e.textContent,n.replaceWith(t)}),mermaid.initialize({startOnLoad:!0,theme:"default"})})()</script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js id=MathJax-script async></script></body></html>